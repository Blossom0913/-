
### 百度松果菁英班刷题题解

<center>
2023Fall
</center>

- week2

1. 第一题——小码哥的抽卡率
>小码哥最近迷上了一款抽卡游戏。单抽出金的概率是0.6%，如果前89发都不出金，则90发必出金。小码哥目前存了一些抽数，想要你帮他算算他出金的概率。

- 格式
    - 输入格式:一个整数 n，表示小码哥的抽数
    - 输出格式:一个百分数 p，表示出金的概率，保留六位小数(按所给样例)

- 解题思路：
  假设小码在第n发抽中，说明前面n-1发miss，那么这一发的概率就是$(1-p)^{n-1}p$,那么n发出金的概率就是把第i发出金的概率都sum起来，即$P = \sum_{i=0}^{n-1}(1-p)^ip$

- My Code：
```c
#include<stdio.h>
int main() 
{ 
    int n;
    scanf("%d",&n);
    double p = 0.006;
    if(n==90){
        printf("100.000000\%\n");}
    else{
        double ans = p;
        double pnow = p;
        for(int i = 1;i < n;++i){
            pnow *= 1-p;
            ans += pnow;
        }
        ans *= 100;
        printf("%.6f\%\n",ans);
    }

    return 0; 
}
```
2. 第二题——抽奖概率

>小码哥正在进行抽奖，箱子里有一红一白两小球，每次摸出一个球，摸到红球中奖，如果中奖就不再继续抽奖，如果未中奖(摸到白球)，则往箱子里补充一个白球(摸出的白球不放回)，继续抽奖，直到中奖，或者达到最大抽奖次数。
假设至多能抽奖 M 次，求当停止抽奖时，(中奖球数/摸出总球数) 的期望
- 格式
    - 输入格式:一行，一个整数 M
    - 输出格式:保留到小数后六位

- 解题思路：
  注意题目中说摸出白球不放回，那么盒子始终都是1个红球和1个白球，那么第m发就是$\frac{1}{2^m}$的概率，再乘上(中奖球数/摸出总球数)=$\frac{1}{m}，E=\frac{1}{m}*\frac{1}{2^m}，$然后也是从1到M求和就可以

- My Code：
```c
#include<stdio.h>
int main() 
{ 
    int m;
    scanf("%d",&m);
    double ans = 0.0;
    double p = 1.0;
    for(int i = 1;i <= m;++i){
        p *= 0.5;
        ans += (1.0 / i)*p;
    }
    printf("%.6f\n",ans);
    return 0; 
}
```  
3. 第三题——赌石
>根据赌徒的心理设计了一个有趣的买卖规则: 他在店铺的两边放了个小桶，一个桶里有 n 个红球，另一个有 n 个蓝球。每一批 2n 个璞石与这些球一一对应，对每个来买璞石的客户，小码哥都会让他们在原地闭眼旋转数圈后走向一个小桶，若拿到蓝球则可免费获得一块石头，但若拿到红球则需要付出两倍的价钱。
假设每个人每次拿到蓝球和红球的概率相同，现在请你求出一人桶里没球而另一个桶里还剩两个球的概率，精确到小数点后四位。
- 格式
    - 输入格式: 输入一个正整数代表这批璞石的个数(不大于2500，且保证为偶数)
    - 输出格式: 输出一个四位小数代表所求答案

- 解题思路：
  这时候一共还剩2个球，说明卖出了2n-2个球，那么我们只考虑问题的反面，就是当两个桶里面各有一个球的概率，然后取概率反就是答案，求解并不难$p = C_{2n-2}^{n-1}\frac{1}{2^{2n-2}}$

- My Code：
```c
#include<stdio.h>
int main() 
{ 
    int n;
    scanf("%d",&n);
    n /= 2;
    double ans = 1.0;
    for(int i = 1;i < n;i++){
        ans *= (double)(n-1+i)/(4*i);
    }
    printf("%.4lf\n",1 - ans);


    return 0; 
}
```

4. 第四题——甜甜花的研究

>小码哥酷爱研究植物，他对甜甜花的研究无人能及，可他仍然在不断研究着。现在小码哥有 n 粒甜甜花的种子，每一粒种子都能长出不同的甜甜花，由于种子实在太多，小码哥一个人实在无法照料，于是他雇佣了 m 位种植能手，第a个人能照料$a_i$株甜甜花，请问小码哥有多少种分配方式将这些种子分配出去?
- 格式
    - 输入格式: 输入共两行，第一行输入用空格隔开的两个正整数 n，m;第二行输入 m 个正整数，分别代表 $a_i$,数据保证种子有剩余。
    - 输出格式:输出一个整数表示方法个数，由于结果可能很大，须将结果对12520取模

- 解题思路：
  就怎么说，我刚开始还担心工人能照顾的种子数超过总和那要加个条件判断有点麻烦，但是下面条件就马上告诉我数据保证种子有剩余。那就变成一个很简单的一次求组合然后相乘的问题了：$N = \prod_{i=1}^N C_{n-sum(a_{i-1})}^{a_i}$

- My Code：
```c
#include<stdio.h>
#include<stdlib.h>

int zuhe(int n,int m){
    double ans = 1;
    for(int i = 1;i <= n;++i){
        ans *= (double)m;
        ans /= (double)i;
        m--;
    }
    return (int)ans;
}

int main() 
{ 
    int n,m;
    scanf("%d %d",&n,&m);
    int* a = (int*)malloc(sizeof(int)*m);
    for(int i = 0;i < m;++i){
        scanf("%d ",a+i);
    }
    int ans = 1;
    for(int i = 0;i < m;++i){
        ans *= zuhe(a[i],n);
        n -= a[i];
    }
    printf("%d\n",ans%12520);
    return 0; 
}
```

5. 第五题——饿饿！饭饭！
>嗯哼，小码哥在新的一年里不会忘记身为干饭人的初心，众所周知，小码哥非常不喜欢一直吃同样的东西，但由于理想与现实的差距，食堂在这 n 天里只会供应 k 种餐食。
在一天吃3餐的情况下，前 w 天一共 w*3 顿饭小码哥不希望有任何一顿重复。现在请问食堂有多少种方案可以满足超级可爱乖巧的小码哥的需要。
- 格式
    - 输入格式: 一行，三个整数 n，k，w 表示 n 天内食堂只会供应 k 种餐食，w 的意义详见题面。
    - 输出格式: 输出一行一个数，表示满足小码哥需要的方案数。

- 解题思路：
  怎么说，刚开始我还疑惑为什么这种组合问题会用到排列，瞄一眼题解之后才发现只要在k个餐中取3w个然后全排列就完事了$N = C_k^{3w}A_{3w}$

- My Code：
```c
#include<stdio.h>

int zuhe(int n,int m){
    double ans = 1;
    for(int i = 1;i <= n;++i){
        ans *= (double)m;
        ans /= (double)i;
        m--;
    }
    return (int)ans;
}

int main() 
{ 
    int n,k,w;
    scanf("%d %d %d",&n,&k,&w);
    
    if(k < 3*w)
        printf("0\n");
    else{
        int ans = zuhe(3*w,k);
        for(int i=1;i <= 3*w;++i){
            ans *= i;
        }
        printf("%d\n",ans);
    }
    return 0; 
}
```